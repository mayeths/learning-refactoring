# *Refactoring* 阅读笔记

[Refactoring: improving the design of existing code (2nd Edition)](https://refactoring.com/)

有条件者，推荐购买 [实体书籍](https://item.jd.com/12584498.html) 或电子版进行阅读。此文档仅为个人笔记，不能包含所有内容（手法），且带有个人意见的附注和修改。本文档会有未记载的手法，如果需要的话，直接阅读原文会比较好。

本书中的「重构」一词表示一种特定的清理代码的方式，不会改变软件可观察的行为。这意味着，**严格按照重构手法修改的代码很少进入不可工作的状态**，即便重构没有完成，也（几乎）可以随时随地停下来。如果有人说他们的代码在重构时有一两天时间不可用，基本上可以确定他们做的事不是重构，那是重写。（p.46）

重构不应对原行为产生影响，如果已经存在被观测到的 bug ，则使用下列手法重构结束后其依然要存在；如果没有还产生影响，也可以顺手修复它们。

阅读笔记的记录格式：
- 名称
- *简介（如果无法使用 200 字阐述，则阅读毫无意义）
- 代码展示（摘于 [官网目录](https://refactoring.com/catalog/) ）
- 动机（为什么要做这个重构 & 什么情况下不该做这个重构）
- 步骤（实现此重构遵循的流程）
- *笔记（其他思考）

---

## 目录
- [*Refactoring* 阅读笔记](#refactoring-阅读笔记)
  - [目录](#目录)
  - [书中部分术语的提前声明](#书中部分术语的提前声明)
    - [命令与查询](#命令与查询)
  - [何时重构 p.50](#何时重构-p50)
  - [重构与性能 p.65](#重构与性能-p65)
  - [代码的坏味道 p.71](#代码的坏味道-p71)
  - [构筑测试体系 p.85](#构筑测试体系-p85)
  - [第一组重构 p.106](#第一组重构-p106)
    - [提炼函数（Extract Function）](#提炼函数extract-function)

<br />

## 书中部分术语的提前声明

### 命令与查询

- 命令：带有副作用（与非局部变量进行交互，如 IO 、修改全局变量）的函数
- 查询：带有返回值的函数

一般来说，应该保持命令与查询的分离。查询保持纯函数的性质，不论多少次调用都不会产生影响。

<br />

## 何时重构 p.50

- 预备性重构：使添加功能更容易。「如果对现有代码库进行微调，会使修复 bug 或添加新功能更容易」
- 帮助理解的重构：使代码更易懂。「无法理解现有代码，或理解起来又困难的时候，可以进行重构」
- 捡垃圾式的重构：我理解代码在干什么，但发现它做的不够好。
- 有计划的重构和见机行事的重构：一般不会给重构留出单独的时间，应该在做其他事的时候自然而然地发生重构。上面提到的都是见机行事的重构。

注意：每次要修改时，首先要使修改变得容易（p.53）。因而下面的部分重构手法（大多数在「第一组重构」中）是很重要的，并且其他一些重构会因准备工作而显得比较迂回。

<br />

## 重构与性能 p.65

- 对于实时系统（心率调节器等），应采用时间预算法，给每个组件做好预算，并持续关注；
- 而对于其他系统（诸如用户界面系统、企业信息系统），这样就会大动干戈了。实际上，如果对大多数程序进行分析，会发现它的大半部分时间都用在一小部分代码上，这意味着持续关注进行的90%的优化工作是白费劲的（因为那些优化部分很少被执行）。一种比较合理的解决方案是，直到发生了可观测的性能问题时，再遵循性能优化手法进行调优；否则，重构等手法带来的性能影响都应该忽略不计。而且，重构后的代码更易于展开优化。

重构与性能优化有很多相似之处，但他们不一样：

- 重构为了让代码更容易理解，更易于修改，有可能导致程序更快，也可能更慢；
- 性能优化只关心让程序运行地更快，但最终的代码可能更难以理解和维护（要有心理准备）。

<br />

## 代码的坏味道 p.71

什么时候应该开展重构？代码有坏味道的时候。下面的几种坏味道描述地很抽象，因而可以直接跳过。

- 神秘命名（Mysterious Name）
  - 命名是编程中最难的事之一（个人附注：无头绪的时候，可以到 [codeif](https://unbug.github.io/codelf/) 去查翻译。有趣的是，网站显示的那句话就是本书的作者说的）。当出现不好的名字时，往往以为着更深层次的设计问题（如一个函数做了太多事情）。这时候可能会需要 `变量改名` 、`字段改名` 等手法。
- 重复代码（Duplicated Code）
  - 事不过三，三则重构。(使用 `提炼函数` 的手法)
- 过长函数（Long Function）
  - 百分之九十的场合里，要把函数变短只需要展开 `提炼函数` 的手法。每当你觉得需要注释来说明什么的时候，就是提炼函数的最好时候。函数名？浓缩一下写出来的注释就有了。
- 过长参数列表（Long Parameter List）
  - 如果有几个参数总是一同出现，可以使用 `引入参数对象` 的手法。
  - 如果某个参数其实可以通过发起查询而获得，那么就应该在函数里进行查询（`以查询取代参数`）
  - 如果某个参数用于区分函数的行为，则使用 `移除标记参数` 的手法。
- 全局变量（Global Data）
  - 除非你正在用 C语言 写操作系统，否则使用 `封装变量` 手法进行重构。
- 可变数据（Mutable Data）
  - 可以用 `封装变量` 确保所有数据更新操作都只通过几个函数来进行。
- 发散式变化（Divergent Change）
  - 我们希望一旦需要修改某个模块，就能直接跳到该模块的某一点，只在该处进行修改。如果不能做到这一点，那么这就是发散式变化。「每次只关心一个上下文」很重要，可能需要 `搬移函数` 或者 `提炼类` 等手法。
- 霰弹式修改（Shotgun Surgery）
  - 类似于发散式修改，但恰恰相反。霰弹式修改意味着每遇到一种变化，就需要在许多不同的类中做出许多小修改。这种情况下，应该使用 `搬移函数` 或 `函数组合成类` 等手法。
- ...... 其他坏味道情况

<br />

## 构筑测试体系 p.85

重构是很有价值的工具，但只有重构还不行。要正确地使用重构，前提是得有一套牢固的测试集合，以帮助发现难以避免的疏漏。一个坚固的系统，应该使用一套比较合理的测试框架（如 GTest，JUnit 等）构建一些自动化测试，让所有对系统的修改都能通过测试。

几乎所有编程语言都有测试框架。唯一阻止你使用测试的原因只有没时间写测试代码。但写出一个好的测试框架，可以让开发时有足够的信心推进工作。

注意：
- 你应该总是确保测试不该通过时真的会失败，因而添加几个错误输入时的测试会很有帮助。
- 每当你收到一个 bug 报告，请先写一个单元测试来暴露这个 bug。

要写多少测试才算足够？如果只是个人项目，这个问题没有标准答案。因为这需要你自己根据时间、人力来衡量重构和测试的细节。单元测试是最容易编写的，每当新增一个功能，可以先编写对应的单元测试。

<br />

## 第一组重构 p.106

### 提炼函数（Extract Function）

**简介**

一个函数可以通过调用其他函数来完成任务，最好不要在其内配置子过程来完成任务。子过程越多，代码越长，会导致代码的可复用性、鲁棒性、可阅读性越差。调用函数时，函数名可以透露操作目的，减轻阅读时的心理负担。

**代码展示**

```javascript
//old
function printOwing(invoice) {
  printBanner();
  let outstanding  = calculateOutstanding();

  //print details
  console.log(`name: ${invoice.customer}`);
  console.log(`amount: ${outstanding}`);  
}

//new
function printOwing(invoice) {
  printBanner();
  let outstanding  = calculateOutstanding();
  printDetails(outstanding);

  function printDetails(outstanding) {
    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
  }
}
```

**动机**

- 作为其他手法开展前的准备工作（便于成块地调成目标代码）
- 出现过多个类似的代码段
- 需要花时间才能弄明白函数内的某一段代码在干什么
- 函数承载了太多的功能/步骤（两个？三个？依情况而定）
- 函数内有需要注释的代码段
- 函数太长（作者认为超过6行的代码就是在散发臭味）

**步骤**

- 创建新的空函数，根据意图/行为来命名
  - 从其他函数内抽取出来的代码段，如果原来有注释，从中提炼名称。
  - 如果没有，先写注释（在脑子里也可以），然后使用上面的方法。
  - 需要翻译时，使用 [codeif](https://unbug.github.io/codelf/)。
  - 以做什么来命名，而非怎么做。
- 复制（而不是剪切）源代码到目标函数
- 检查新代码，是否有无法接触的变量（实现功能的代码段一定用到了变量）
  - 如果是支持函数嵌套的语言且只提炼到内部，则不存在此问题。
  - 如果提炼到了外部，则将变量作为参数传入。
  - 如果变量在代码里被赋值或操作，要小心：考虑将传入其引用/指针或者尝试构建查询函数，在原代码中先使用查询为其赋值。
  - 如果参数太多，考虑 `引入参数对象` 或者 `以查询取代临时参数`，甚至停止重构。
- 编译，使新函数能否通过
- 在原函数中将目标代码段替换为新函数调用
- 测试

**笔记**

第一个重构手法，也是最重要的重构手法。在这里，你应该停留足够多的时间来尽量理解此手法，因为其他手法经常需要此作为基础工作。更如果无法理解也没关系，略读一遍本书后再回头看，你会大有收获。

值得注意的是，本书中对于代码变动十分谨慎，力求重构过程不破坏原代码，因而其中一步使用了复制而不是剪切。初读本书，一定会无法理解为何使用如此细碎的脚步。但到后期，手法和代码愈发复杂时，不破坏的重要性就会显现出来。如果重构过程中止，你完全可以直接删除重构部分（或者使用 `git stash`，但这可能需要在重构前 commit 一下），从而恢复现场。

重构不是「银弹」，在重构过程中也许会觉得重构会带来更大的麻烦而决定中止。但一般情况下，导致重构手法 ugly 的根本原因是设计或者其他层面的问题。这时候，你可以选择先使用对应的重构手法来进行提前工作。




<br />

---

*To be continue*